const fs = require('fs');
const path = require('path');
const cheerio = require('cheerio');

/**
 * Extract metadata from an HTML file
 * @param {string} filePath - Path to the HTML file
 * @returns {object|null} - Extracted metadata or null if invalid
 */
function extractMetadata(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const $ = cheerio.load(content);
    const filename = path.basename(filePath);
    
    // Extract metadata from meta tags and title
    const title = $('meta[name="title"]').attr('content') || $('title').text() || filename.replace(/\.[^/.]+$/, "");
    const description = $('meta[name="description"]').attr('content') || '';
    const author = $('meta[name="author"]').attr('content') || '';
    const github = $('meta[name="github"]').attr('content') || '';
    
    // Extract compatible browsers if specified
    const compatibleBrowsersContent = $('meta[name="compatible-browsers"]').attr('content');
    let compatibleBrowsers = [];
    if (compatibleBrowsersContent) {
      compatibleBrowsers = compatibleBrowsersContent.split(',').map(b => b.trim()).filter(b => b);
    }
    
    // Build entry object
    const entry = {
      title: title.trim(),
      filename: filename
    };
    
    if (description) entry.description = description.trim();
    if (author) entry.author = author.trim();
    if (github) entry.github = github.trim();
    if (compatibleBrowsers.length > 0) entry.compatibleBrowsers = compatibleBrowsers;
    
    return entry;
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error.message);
    return null;
  }
}

/**
 * Generate entries.js from all HTML files in the entries directory
 */
function generateEntriesJs() {
  const entriesDir = 'entries';
  
  if (!fs.existsSync(entriesDir)) {
    console.error('Entries directory not found');
    process.exit(1);
  }
  
  const entries = [];
  const files = fs.readdirSync(entriesDir)
    .filter(file => file.match(/\.html?$/i))
    .sort(); // Sort alphabetically for consistent output
  
  console.log(`Processing ${files.length} HTML files...`);
  
  for (const file of files) {
    const filePath = path.join(entriesDir, file);
    const metadata = extractMetadata(filePath);
    
    if (metadata) {
      entries.push(metadata);
      console.log(`✅ ${file}: ${metadata.title}`);
    } else {
      console.log(`❌ ${file}: Failed to extract metadata`);
    }
  }
  
  // Sort entries by title for consistency with current entries.js
  entries.sort((a, b) => a.title.localeCompare(b.title));
  
  // Write JavaScript file
  const jsContent = `/**
 * This file is automatically generated from HTML meta tags.
 * Last updated: ${new Date().toISOString()}
 * 
 * DO NOT EDIT MANUALLY - Changes will be overwritten!
 * To update entries, modify the meta tags in your HTML files.
 */

const entries = ${JSON.stringify(entries, null, 2)};`;

  const jsOutputFile = 'entries.js';
  fs.writeFileSync(jsOutputFile, jsContent, 'utf8');
  
  console.log(`\n✅ Generated ${jsOutputFile} with ${entries.length} entries`);
  
  // Log any files missing metadata
  const missingMetadata = files.filter(file => {
    const filePath = path.join(entriesDir, file);
    const metadata = extractMetadata(filePath);
    return !metadata || !metadata.title || !metadata.description || !metadata.author;
  });
  
  if (missingMetadata.length > 0) {
    console.log(`\n⚠️  Files missing complete metadata:`);
    missingMetadata.forEach(file => {
      const filePath = path.join(entriesDir, file);
      const metadata = extractMetadata(filePath);
      const missing = [];
      if (!metadata || !metadata.title) missing.push('title');
      if (!metadata || !metadata.description) missing.push('description');
      if (!metadata || !metadata.author) missing.push('author');
      console.log(`   ${file}: missing ${missing.join(', ')}`);
    });
  }
}

// Run the generator
generateEntriesJs(); 